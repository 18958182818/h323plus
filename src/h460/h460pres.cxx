//
// H460pres.cxx
//
// Code automatically generated by asnparse.
//

#ifdef P_USE_PRAGMA
#pragma implementation "H460pres.h"
#endif

#include <ptlib.h>
#include "H460pres.h"

#define new PNEW


#if ! H323_DISABLE_H460P



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H460P_PresenceMessage[]={
        {"preState",0}
       ,{"preInstruct",1}
       ,{"preAuthorize",2}
       ,{"preNotify",3}
       ,{"preRequest",4}
       ,{"preResponse",5}
       ,{"preAlive",6}
       ,{"preRemove",7}
       ,{"preAlert",8}
};
#endif
//
// PresenceMessage
//

H460P_PresenceMessage::H460P_PresenceMessage(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 8, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H460P_PresenceMessage,9
#endif
    )
{
}


H460P_PresenceMessage & H460P_PresenceMessage::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H460P_PresenceMessage::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceMessage::Class()), PInvalidCast);
#endif
  return new H460P_PresenceMessage(*this);
}



#ifndef PASN_NOPRINTON
const static PASN_Names Names_H460P_PresenceInstruction[]={
      {"subscribe",0}
     ,{"unsubscribe",1}
     ,{"block",2}
     ,{"unblock",3}
};
#endif
//
// PresenceInstruction
//

H460P_PresenceInstruction::H460P_PresenceInstruction(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Choice(tag, tagClass, 4, TRUE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H460P_PresenceInstruction,4
#endif
)
{
}


#if defined(__GNUC__) && __GNUC__ <= 2 && __GNUC_MINOR__ < 9
H460P_PresenceInstruction::operator H225_AliasAddress &() const
#else
H460P_PresenceInstruction::operator H225_AliasAddress &()
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_AliasAddress), PInvalidCast);
#endif
  return *(H225_AliasAddress *)choice;
}


H460P_PresenceInstruction::operator const H225_AliasAddress &() const
#endif
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(PAssertNULL(choice), H225_AliasAddress), PInvalidCast);
#endif
  return *(H225_AliasAddress *)choice;
}


BOOL H460P_PresenceInstruction::CreateObject()
{
  switch (tag) {
    case e_subscribe :
    case e_unsubscribe :
    case e_block :
    case e_unblock :
      choice = new H225_AliasAddress();
      return TRUE;
  }

  choice = NULL;
  return FALSE;
}


PObject * H460P_PresenceInstruction::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceInstruction::Class()), PInvalidCast);
#endif
  return new H460P_PresenceInstruction(*this);
}


//
// PresenceIdentifier
//

H460P_PresenceIdentifier::H460P_PresenceIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 0, TRUE, 0)
{
  m_guid.SetConstraints(PASN_Object::FixedConstraint, 16);
}


#ifndef PASN_NOPRINTON
void H460P_PresenceIdentifier::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+7) << "guid = " << setprecision(indent) << m_guid << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceIdentifier::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceIdentifier), PInvalidCast);
#endif
  const H460P_PresenceIdentifier & other = (const H460P_PresenceIdentifier &)obj;

  Comparison result;

  if ((result = m_guid.Compare(other.m_guid)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceIdentifier::GetDataLength() const
{
  PINDEX length = 0;
  length += m_guid.GetObjectLength();
  return length;
}


BOOL H460P_PresenceIdentifier::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_guid.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceIdentifier::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_guid.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceIdentifier::Class()), PInvalidCast);
#endif
  return new H460P_PresenceIdentifier(*this);
}


#ifndef PASN_NOPRINTON
const static PASN_Names Names_H460P_PresenceState[]={
        {"presHidden",0}
       ,{"presAvailable",1}
       ,{"presOnline",2}
       ,{"presOffline",3}
       ,{"presOnCall",4}
       ,{"presVoiceMail",5}
       ,{"presNotAvailable",8}
       ,{"presGeneric",9}
};
#endif
//
// PresenceState
//

H460P_PresenceState::H460P_PresenceState(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Enumeration(tag, tagClass, 9, FALSE
#ifndef PASN_NOPRINTON
    ,(const PASN_Names *)Names_H460P_PresenceState,8
#endif
    )
{
}


H460P_PresenceState & H460P_PresenceState::operator=(unsigned v)
{
  SetValue(v);
  return *this;
}


PObject * H460P_PresenceState::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceState::Class()), PInvalidCast);
#endif
  return new H460P_PresenceState(*this);
}


//
// ArrayOf_PresenceNotification
//

H460P_ArrayOf_PresenceNotification::H460P_ArrayOf_PresenceNotification(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_PresenceNotification::CreateObject() const
{
  return new H460P_PresenceNotification;
}


H460P_PresenceNotification & H460P_ArrayOf_PresenceNotification::operator[](PINDEX i) const
{
  return (H460P_PresenceNotification &)array[i];
}


PObject * H460P_ArrayOf_PresenceNotification::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_PresenceNotification::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_PresenceNotification(*this);
}


//
// ArrayOf_PresenceSubscription
//

H460P_ArrayOf_PresenceSubscription::H460P_ArrayOf_PresenceSubscription(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_PresenceSubscription::CreateObject() const
{
  return new H460P_PresenceSubscription;
}


H460P_PresenceSubscription & H460P_ArrayOf_PresenceSubscription::operator[](PINDEX i) const
{
  return (H460P_PresenceSubscription &)array[i];
}


PObject * H460P_ArrayOf_PresenceSubscription::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_PresenceSubscription::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_PresenceSubscription(*this);
}


//
// ArrayOf_PresenceInstruction
//

H460P_ArrayOf_PresenceInstruction::H460P_ArrayOf_PresenceInstruction(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_PresenceInstruction::CreateObject() const
{
  return new H460P_PresenceInstruction;
}


H460P_PresenceInstruction & H460P_ArrayOf_PresenceInstruction::operator[](PINDEX i) const
{
  return (H460P_PresenceInstruction &)array[i];
}


PObject * H460P_ArrayOf_PresenceInstruction::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_PresenceInstruction::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_PresenceInstruction(*this);
}


//
// ArrayOf_PresenceIdentifier
//

H460P_ArrayOf_PresenceIdentifier::H460P_ArrayOf_PresenceIdentifier(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_PresenceIdentifier::CreateObject() const
{
  return new H460P_PresenceIdentifier;
}


H460P_PresenceIdentifier & H460P_ArrayOf_PresenceIdentifier::operator[](PINDEX i) const
{
  return (H460P_PresenceIdentifier &)array[i];
}


PObject * H460P_ArrayOf_PresenceIdentifier::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_PresenceIdentifier::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_PresenceIdentifier(*this);
}


//
// ArrayOf_ClearToken
//

H460P_ArrayOf_ClearToken::H460P_ArrayOf_ClearToken(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_ClearToken::CreateObject() const
{
  return new H235_ClearToken;
}


H235_ClearToken & H460P_ArrayOf_ClearToken::operator[](PINDEX i) const
{
  return (H235_ClearToken &)array[i];
}


PObject * H460P_ArrayOf_ClearToken::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_ClearToken::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_ClearToken(*this);
}


//
// ArrayOf_CryptoH323Token
//

H460P_ArrayOf_CryptoH323Token::H460P_ArrayOf_CryptoH323Token(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_CryptoH323Token::CreateObject() const
{
  return new H225_CryptoH323Token;
}


H225_CryptoH323Token & H460P_ArrayOf_CryptoH323Token::operator[](PINDEX i) const
{
  return (H225_CryptoH323Token &)array[i];
}


PObject * H460P_ArrayOf_CryptoH323Token::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_CryptoH323Token::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_CryptoH323Token(*this);
}


//
// ArrayOf_AliasAddress
//

H460P_ArrayOf_AliasAddress::H460P_ArrayOf_AliasAddress(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_AliasAddress::CreateObject() const
{
  return new H225_AliasAddress;
}


H225_AliasAddress & H460P_ArrayOf_AliasAddress::operator[](PINDEX i) const
{
  return (H225_AliasAddress &)array[i];
}


PObject * H460P_ArrayOf_AliasAddress::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_AliasAddress::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_AliasAddress(*this);
}


//
// ArrayOf_GenericData
//

H460P_ArrayOf_GenericData::H460P_ArrayOf_GenericData(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Array(tag, tagClass)
{
}


PASN_Object * H460P_ArrayOf_GenericData::CreateObject() const
{
  return new H225_GenericData;
}


H225_GenericData & H460P_ArrayOf_GenericData::operator[](PINDEX i) const
{
  return (H225_GenericData &)array[i];
}


PObject * H460P_ArrayOf_GenericData::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_ArrayOf_GenericData::Class()), PInvalidCast);
#endif
  return new H460P_ArrayOf_GenericData(*this);
}


//
// PresencePDU
//

H460P_PresencePDU::H460P_PresencePDU(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 6, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresencePDU::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+12) << "messageId = " << setprecision(indent) << m_messageId << '\n';
  if (HasOptionalField(e_notification))
    strm << setw(indent+15) << "notification = " << setprecision(indent) << m_notification << '\n';
  if (HasOptionalField(e_subscription))
    strm << setw(indent+15) << "subscription = " << setprecision(indent) << m_subscription << '\n';
  if (HasOptionalField(e_instruction))
    strm << setw(indent+14) << "instruction = " << setprecision(indent) << m_instruction << '\n';
  if (HasOptionalField(e_identifier))
    strm << setw(indent+13) << "identifier = " << setprecision(indent) << m_identifier << '\n';
  if (HasOptionalField(e_tokens))
    strm << setw(indent+9) << "tokens = " << setprecision(indent) << m_tokens << '\n';
  if (HasOptionalField(e_cryptoTokens))
    strm << setw(indent+15) << "cryptoTokens = " << setprecision(indent) << m_cryptoTokens << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresencePDU::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresencePDU), PInvalidCast);
#endif
  const H460P_PresencePDU & other = (const H460P_PresencePDU &)obj;

  Comparison result;

  if ((result = m_messageId.Compare(other.m_messageId)) != EqualTo)
    return result;
  if ((result = m_notification.Compare(other.m_notification)) != EqualTo)
    return result;
  if ((result = m_subscription.Compare(other.m_subscription)) != EqualTo)
    return result;
  if ((result = m_instruction.Compare(other.m_instruction)) != EqualTo)
    return result;
  if ((result = m_identifier.Compare(other.m_identifier)) != EqualTo)
    return result;
  if ((result = m_tokens.Compare(other.m_tokens)) != EqualTo)
    return result;
  if ((result = m_cryptoTokens.Compare(other.m_cryptoTokens)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresencePDU::GetDataLength() const
{
  PINDEX length = 0;
  length += m_messageId.GetObjectLength();
  if (HasOptionalField(e_notification))
    length += m_notification.GetObjectLength();
  if (HasOptionalField(e_subscription))
    length += m_subscription.GetObjectLength();
  if (HasOptionalField(e_instruction))
    length += m_instruction.GetObjectLength();
  if (HasOptionalField(e_identifier))
    length += m_identifier.GetObjectLength();
  if (HasOptionalField(e_tokens))
    length += m_tokens.GetObjectLength();
  if (HasOptionalField(e_cryptoTokens))
    length += m_cryptoTokens.GetObjectLength();
  return length;
}


BOOL H460P_PresencePDU::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_messageId.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_notification) && !m_notification.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_subscription) && !m_subscription.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_instruction) && !m_instruction.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_identifier) && !m_identifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_tokens) && !m_tokens.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_cryptoTokens) && !m_cryptoTokens.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresencePDU::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_messageId.Encode(strm);
  if (HasOptionalField(e_notification))
    m_notification.Encode(strm);
  if (HasOptionalField(e_subscription))
    m_subscription.Encode(strm);
  if (HasOptionalField(e_instruction))
    m_instruction.Encode(strm);
  if (HasOptionalField(e_identifier))
    m_identifier.Encode(strm);
  if (HasOptionalField(e_tokens))
    m_tokens.Encode(strm);
  if (HasOptionalField(e_cryptoTokens))
    m_cryptoTokens.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresencePDU::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresencePDU::Class()), PInvalidCast);
#endif
  return new H460P_PresencePDU(*this);
}


//
// PresenceSubscription
//

H460P_PresenceSubscription::H460P_PresenceSubscription(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 4, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceSubscription::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+11) << "approved = " << setprecision(indent) << m_approved << '\n';
  strm << setw(indent+12) << "subscribe = " << setprecision(indent) << m_subscribe << '\n';
  strm << setw(indent+10) << "aliases = " << setprecision(indent) << m_aliases << '\n';
  if (HasOptionalField(e_rasAddress))
    strm << setw(indent+13) << "rasAddress = " << setprecision(indent) << m_rasAddress << '\n';
  if (HasOptionalField(e_timeToLive))
    strm << setw(indent+13) << "timeToLive = " << setprecision(indent) << m_timeToLive << '\n';
  if (HasOptionalField(e_identifier))
    strm << setw(indent+13) << "identifier = " << setprecision(indent) << m_identifier << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceSubscription::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceSubscription), PInvalidCast);
#endif
  const H460P_PresenceSubscription & other = (const H460P_PresenceSubscription &)obj;

  Comparison result;

  if ((result = m_approved.Compare(other.m_approved)) != EqualTo)
    return result;
  if ((result = m_subscribe.Compare(other.m_subscribe)) != EqualTo)
    return result;
  if ((result = m_aliases.Compare(other.m_aliases)) != EqualTo)
    return result;
  if ((result = m_rasAddress.Compare(other.m_rasAddress)) != EqualTo)
    return result;
  if ((result = m_timeToLive.Compare(other.m_timeToLive)) != EqualTo)
    return result;
  if ((result = m_identifier.Compare(other.m_identifier)) != EqualTo)
    return result;
  if ((result = m_genericData.Compare(other.m_genericData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceSubscription::GetDataLength() const
{
  PINDEX length = 0;
  length += m_approved.GetObjectLength();
  length += m_subscribe.GetObjectLength();
  length += m_aliases.GetObjectLength();
  if (HasOptionalField(e_rasAddress))
    length += m_rasAddress.GetObjectLength();
  if (HasOptionalField(e_timeToLive))
    length += m_timeToLive.GetObjectLength();
  if (HasOptionalField(e_identifier))
    length += m_identifier.GetObjectLength();
  if (HasOptionalField(e_genericData))
    length += m_genericData.GetObjectLength();
  return length;
}


BOOL H460P_PresenceSubscription::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_approved.Decode(strm))
    return FALSE;
  if (!m_subscribe.Decode(strm))
    return FALSE;
  if (!m_aliases.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_rasAddress) && !m_rasAddress.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_timeToLive) && !m_timeToLive.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_identifier) && !m_identifier.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_genericData) && !m_genericData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceSubscription::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_approved.Encode(strm);
  m_subscribe.Encode(strm);
  m_aliases.Encode(strm);
  if (HasOptionalField(e_rasAddress))
    m_rasAddress.Encode(strm);
  if (HasOptionalField(e_timeToLive))
    m_timeToLive.Encode(strm);
  if (HasOptionalField(e_identifier))
    m_identifier.Encode(strm);
  if (HasOptionalField(e_genericData))
    m_genericData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceSubscription::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceSubscription::Class()), PInvalidCast);
#endif
  return new H460P_PresenceSubscription(*this);
}


//
// Presentity
//

H460P_Presentity::H460P_Presentity(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 3, TRUE, 0)
{
  m_display.SetConstraints(PASN_Object::FixedConstraint, 1, 256);
}


#ifndef PASN_NOPRINTON
void H460P_Presentity::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+8) << "state = " << setprecision(indent) << m_state << '\n';
  if (HasOptionalField(e_display))
    strm << setw(indent+10) << "display = " << setprecision(indent) << m_display << '\n';
  if (HasOptionalField(e_geolocation))
    strm << setw(indent+14) << "geolocation = " << setprecision(indent) << m_geolocation << '\n';
  if (HasOptionalField(e_genericData))
    strm << setw(indent+14) << "genericData = " << setprecision(indent) << m_genericData << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_Presentity::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_Presentity), PInvalidCast);
#endif
  const H460P_Presentity & other = (const H460P_Presentity &)obj;

  Comparison result;

  if ((result = m_state.Compare(other.m_state)) != EqualTo)
    return result;
  if ((result = m_display.Compare(other.m_display)) != EqualTo)
    return result;
  if ((result = m_geolocation.Compare(other.m_geolocation)) != EqualTo)
    return result;
  if ((result = m_genericData.Compare(other.m_genericData)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_Presentity::GetDataLength() const
{
  PINDEX length = 0;
  length += m_state.GetObjectLength();
  if (HasOptionalField(e_display))
    length += m_display.GetObjectLength();
  if (HasOptionalField(e_geolocation))
    length += m_geolocation.GetObjectLength();
  if (HasOptionalField(e_genericData))
    length += m_genericData.GetObjectLength();
  return length;
}


BOOL H460P_Presentity::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_state.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_display) && !m_display.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_geolocation) && !m_geolocation.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_genericData) && !m_genericData.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_Presentity::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_state.Encode(strm);
  if (HasOptionalField(e_display))
    m_display.Encode(strm);
  if (HasOptionalField(e_geolocation))
    m_geolocation.Encode(strm);
  if (HasOptionalField(e_genericData))
    m_genericData.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_Presentity::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_Presentity::Class()), PInvalidCast);
#endif
  return new H460P_Presentity(*this);
}


//
// PresenceNotification
//

H460P_PresenceNotification::H460P_PresenceNotification(unsigned tag, PASN_Object::TagClass tagClass)
  : PASN_Sequence(tag, tagClass, 1, TRUE, 0)
{
}


#ifndef PASN_NOPRINTON
void H460P_PresenceNotification::PrintOn(ostream & strm) const
{
  int indent = strm.precision() + 2;
  strm << "{\n";
  strm << setw(indent+15) << "aliasAddress = " << setprecision(indent) << m_aliasAddress << '\n';
  strm << setw(indent+13) << "presentity = " << setprecision(indent) << m_presentity << '\n';
  if (HasOptionalField(e_subscribers))
    strm << setw(indent+14) << "subscribers = " << setprecision(indent) << m_subscribers << '\n';
  strm << setw(indent-1) << setprecision(indent-2) << "}";
}
#endif


PObject::Comparison H460P_PresenceNotification::Compare(const PObject & obj) const
{
#ifndef PASN_LEANANDMEAN
  PAssert(PIsDescendant(&obj, H460P_PresenceNotification), PInvalidCast);
#endif
  const H460P_PresenceNotification & other = (const H460P_PresenceNotification &)obj;

  Comparison result;

  if ((result = m_aliasAddress.Compare(other.m_aliasAddress)) != EqualTo)
    return result;
  if ((result = m_presentity.Compare(other.m_presentity)) != EqualTo)
    return result;
  if ((result = m_subscribers.Compare(other.m_subscribers)) != EqualTo)
    return result;

  return PASN_Sequence::Compare(other);
}


PINDEX H460P_PresenceNotification::GetDataLength() const
{
  PINDEX length = 0;
  length += m_aliasAddress.GetObjectLength();
  length += m_presentity.GetObjectLength();
  if (HasOptionalField(e_subscribers))
    length += m_subscribers.GetObjectLength();
  return length;
}


BOOL H460P_PresenceNotification::Decode(PASN_Stream & strm)
{
  if (!PreambleDecode(strm))
    return FALSE;

  if (!m_aliasAddress.Decode(strm))
    return FALSE;
  if (!m_presentity.Decode(strm))
    return FALSE;
  if (HasOptionalField(e_subscribers) && !m_subscribers.Decode(strm))
    return FALSE;

  return UnknownExtensionsDecode(strm);
}


void H460P_PresenceNotification::Encode(PASN_Stream & strm) const
{
  PreambleEncode(strm);

  m_aliasAddress.Encode(strm);
  m_presentity.Encode(strm);
  if (HasOptionalField(e_subscribers))
    m_subscribers.Encode(strm);

  UnknownExtensionsEncode(strm);
}


PObject * H460P_PresenceNotification::Clone() const
{
#ifndef PASN_LEANANDMEAN
  PAssert(IsClass(H460P_PresenceNotification::Class()), PInvalidCast);
#endif
  return new H460P_PresenceNotification(*this);
}


#endif // if ! H323_DISABLE_H460P


// End of H460pres.cxx
